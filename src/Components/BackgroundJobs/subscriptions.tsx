import { useCallback, useEffect } from "react"
import { useDispatch, useSelector } from "../../State/store"
import { Subscription, SubscriptionPayment, addSubPayment, updateActiveSub } from "../../State/Slices/subscriptionsSlice"
import { InputClassification, openNotification, usdToBTCSpotLink } from "../../constants"
import { createLnurlInvoice, handlePayInvoice } from "../../Api/helpers"
import axios from "axios"
import { parseNprofile } from "../../Api/nostr"
import { setLatestOperation } from "../../State/Slices/HistorySlice"
import { UserOperationType } from "../../Api/autogenerated/ts/types"
import { addNotification } from "../../State/Slices/notificationSlice"
const SubsCheckIntervalSeconds = 60 * 60
export const SubscriptionsBackground = () => {
	const activeSubs = useSelector(({ subscriptions }) => subscriptions.activeSubs.filter(s => s.enabled))
	const payments = useSelector(({ subscriptions }) => subscriptions.payments)
	const BTCUSDUrl = useSelector(({ prefs }) => prefs.BTCUSDUrl)
	const spendSources = useSelector((state) => state.spendSource.filter(s => !s.disabled));
	const dispatch = useDispatch();



	const sendSubPayment = useCallback(async (sub: Subscription, latestPayment: SubscriptionPayment | null) => {
		if (sub.destionation.type !== InputClassification.LN_ADDRESS) {
			console.log("subscription payment destionation not supported", sub.destionation.type)
			return
		}
		try {
			let sats = sub.price.amt
			const spendSource = spendSources[0]
			if (sub.price.type === 'cents') {
				const { data } = await axios.get(BTCUSDUrl || usdToBTCSpotLink);
				const btcUsd = data.amount as number
				const satsUsd = btcUsd / 100_000_000
				sats = (sub.price.amt / 100) / satsUsd
			}
			const invoice = await createLnurlInvoice(sats, sub.destionation);
			const payRes = await handlePayInvoice(invoice, spendSource.pasteField);
			const now = Date.now() / 1000
			dispatch(setLatestOperation({
				pub: parseNprofile(spendSource.pasteField).pubkey, operation: {
					amount: sats, identifier: invoice, inbound: false, operationId: payRes.operation_id,
					paidAtUnix: now, type: UserOperationType.OUTGOING_INVOICE, network_fee: payRes.network_fee, service_fee: payRes.service_fee,
					confirmed: true,
				}
			}))
			const periodNumber = latestPayment ? latestPayment.periodNumber + 1 : 1
			const periodStartUnix = latestPayment ? latestPayment.periodEndUnix : sub.subbedAtUnix
			dispatch(addSubPayment({
				payment: {
					operationId: payRes.operation_id,
					paidSats: sats,
					subId: sub.subId,
					periodNumber,
					periodStartUnix,
					periodEndUnix: periodStartUnix + sub.periodSeconds
				}
			}))
		} catch (err: any) {
			console.log("failed to renew sub", sub.subId);
			dispatch(addNotification({
				header: 'Recurring Payment Error',
				icon: '⚠️',
				desc: `Failed to pay recurring payment. Reason: ${err.message}`,
				date: Date.now(),
				link: '/automation',
			}))
			dispatch(updateActiveSub({ sub: { ...sub, unsubReason: "failure", unsubbedAtUnix: Math.floor(Date.now() / 1000) }}));
			console.log(err)
			return
		}
		openNotification("top", "Success", "Subscription renewed.");
	}, [BTCUSDUrl, dispatch, spendSources])

	const checkSubsState = useCallback(() => {
		console.log("checking subscriptions state...")
		const nowUnix = Math.floor(Date.now() / 1000)
		activeSubs.forEach(sub => {
			let maxEnd = 0
			let maxIndex = -1
			const subPayments = (payments[sub.subId] || [])
			subPayments.forEach((payment, index) => {
				if (payment.periodEndUnix > maxEnd) {
					maxEnd = payment.periodEndUnix
					maxIndex = index
				}
			})
			/* if (maxEnd < nowUnix && maxIndex !== -1) {
				console.log("sub", sub.subId, "expired")
				dispatch(updateActiveSub({ sub: { ...sub, unsubReason: "expire", unsubbedAtUnix: Math.floor(Date.now() / 1000) }}));
				return
			} */
			if (maxEnd > nowUnix) {
				console.log("sub", sub.subId, "is up to date")
				return
			}
			console.log("subscription", sub.subId, "needs renew")
			sendSubPayment(sub, maxIndex !== -1 ? subPayments[maxIndex] : null)
		})
	}, [activeSubs, dispatch, payments, sendSubPayment])

	useEffect(() => {
		const interval = setInterval(() => {
			checkSubsState()
		}, SubsCheckIntervalSeconds * 1000)
		checkSubsState()
		return () => {
			clearInterval(interval)
		}
	}, [checkSubsState])



	return null
}